package 数据结构与算法学习笔记.BinaryTree二叉树;

//二叉树是每个节点最多有两个子树的树结构，子树有左右之分，二叉树常被用于实现二叉查找树和二叉堆

/**
 * http://algorithm.yuanbin.me/zh-hans/basics_data_structure/binary_tree.html
 * 树的遍历

 从二叉树的根节点出发，节点的遍历分为三个主要步骤：对当前节点进行操作（称为“访问”节点，或者根节点）、遍历左边子节点、遍历右边子节点。
 访问节点顺序的不同也就形成了不同的遍历方式。需要注意的是树的遍历通常使用递归的方法进行理解和实现，
 在访问元素时也需要使用递归的思想去理解。实际实现中对于前序和中序遍历可尝试使用递归实现。
 按照访问根元素(当前元素)的前后顺序，遍历方式可划分为如下几种：
 深度优先：先访问子节点，再访问父节点，最后访问第二个子节点。根据根节点相对于左右子节点的访问先后顺序又可细分为以下三种方式。
 前序(pre-order)：先根后左再右
 中序(in-order)：先左后根再右
 后序(post-order)：先左后右再根
 广度优先：先访问根节点，沿着树的宽度遍历子节点，直到所有节点均被访问为止。
 如下图所示，遍历顺序在右侧框中，红色A为根节点。使用递归和整体的思想去分析遍历顺序较为清晰。
 二叉树的广度优先遍历和树的前序/中序/后序遍历不太一样，前/中/后序遍历使用递归，
 也就是栈的思想对二叉树进行遍历，广度优先一般使用队列的思想对二叉树进行遍历。
 如果已知中序遍历和前序遍历或者后序遍历，那么就可以完全恢复出原二叉树结构。
 其中最为关键的是前序遍历中第一个一定是根，而后序遍历最后一个一定是根，
 中序遍历在得知根节点后又可进一步递归得知左右子树的根节点。但是这种方法也是有适用范围的：元素不能重复！否则无法完成定位。

            A
        /       \
       B        C
     /  \     /   \
    D   E    F

     前序:ABDECF
     中序 DBEAFC
     后序 DBEFCA
     广度:ABCDEF

 如果已知中序遍历和前序遍历或者后序遍历，那么就可以完全恢复出原二叉树结构。
 其中最为关键的是前序遍历中第一个一定是根，而后序遍历最后一个一定是根，
 中序遍历在得知根节点后又可进一步递归得知左右子树的根节点。但是这种方法也是有适用范围的：元素不能重复！否则无法完成定位。
 */
public class TreeNode {
    public int val;
    public TreeNode left, right;
    public TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}