package cache;
/**
引子：
我们平时总会有一个电话本记录所有朋友的电话，但是，如果有朋友经常联系，那些朋友的电话号码不用翻电话本我们也能记住，
但是，如果长时间没有联系了，
要再次联系那位朋友的时候，我们又不得不求助电话本，但是，通过电话本查找还是很费时间的。但是，我们大脑能够记住的东西是一定的，
我们只能记住自己最熟悉的，而长时间不熟悉的自然就忘记了。
其实，计算机也用到了同样的一个概念，我们用缓存来存放以前读取的数据，而不是直接丢掉，这样，再次读取的时候，可以直接在缓存里面取，
而不用再重新查找一遍，这样系统的反应能力会有很大提高。但是，当我们读取的个数特别大的时候，
我们不可能把所有已经读取的数据都放在缓存里，毕竟内存大小是一定的，我们一般把最近常读取的放在缓存里
（相当于我们把最近联系的朋友的姓名和电话放在大脑里一样）。现在，我们就来研究这样一种缓存机制。
LRU缓存：
LRU缓存利用了这样的一种思想。LRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，
也就是说，LRU缓存把最近最少使用的数据移除，让给最新读取的数据。而往往最常读取的，也是读取次数最多的，
所以，利用LRU缓存，我们能够提高系统的performance.
实现：
要实现LRU缓存，我们首先要用到一个类 LinkedHashMap。 用这个类有两大好处：一是它本身已经实现了按照访问顺序的存储，
也就是说，最近读取的会放在最前面，最最不常读取的会放在最后（当然，它也可以实现按照插入顺序存储）。
第二，LinkedHashMap本身有一个方法用于判断是否需要移除最不常读取的数，但是，原始方法默认不需要移除（
这是，LinkedHashMap相当于一个linkedlist），所以，我们需要override这样一个方法，使得当缓存里存放的数据个数超过规定个数后，
就把最不常用的移除掉。LinkedHashMap的API写得很清楚，推荐大家可以先读一下。
要基于LinkedHashMap来实现LRU缓存，我们可以选择inheritance, 也可以选择 delegation， 我更喜欢delegation。
基于delegation的实现已经有人写出来了，而且写得很漂亮，我就不班门弄斧了。代码如下：
**/