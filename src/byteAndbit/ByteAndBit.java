package byteAndbit;
public class ByteAndBit{
	public static void main(String[]args){
		byte a = 13;
		byte b = (byte) ~a;
		System.out.println(b); // 输出：-14

		/* 
		 * 计算机系统中均以二进制的补码形式进行运算。
		 * 13的二进制补码：0000 1101(非负数的补码与原码相同)
		 * 1+1*2*2+1*2*2*2=13
		 * 将13的二进制补码逐位取反，得到b的补码：1111 0010
		 * 推算出
		 * b的反码：1111 0001
		 * b的原码：1000 1110
		 * b = -14
		 */
		byte x = -3;
		byte y = (byte)~x;
		System.out.println(y);  //输出：2
		/*
		 * -3的原码为：1000 0011
		 * -3的反码为：1111 1100
		 * -3的补码为：1111 1101
		 * 将-3的补码逐位取反，得到y的补码：0000 0010
		 * y的补码为正，所以y为正数，y的原码为：0000 0010
		 * y = 2
		 */
	}
	/**
	 * 位运算符">>"用于将指定整数的二进制形式全部向右移动指定的位数(包括符号位)，
	 * 移动后，右侧超出范围的部分直接舍弃，左侧空出来的部分全部用符号位的数字来补充。
	 */
	public static void rightmove(){
		byte a = 25 >> 2;
		/*
		 * 25的补码为：0001 1001
		 * 右移2位为：**00 0110(右侧超出的"01"被舍弃掉)
		 * 右侧空出来的部分全部用符号位填充，符号位是0，所以得到的结果为：
		 * 0000 0110
		 * 换算为十进制为6
		 */

		byte b = 3 >> 5;
		/*
		 * 3的补码为：0000 0011
		 * 右移5位为：**** *000(右侧超出的"0 0011"被舍弃掉)
		 * 右侧空出来的部分用符号位填充得到：0000 0000
		 * 换算为十进制为0 
		 */

		byte c = -9 >> 2;
		/*
		 * -9的原码为：1000 1001
		 * -9的反码为：1111 0110
		 * -9的补码为：1111 0111
		 * 右移2位为：**11 1101(右侧超出的"11"被舍弃掉)
		 * 右侧空出来的部分用符号位填充，符号位是1，所以得到的结果为：
		 * 1111 1101
		 * 计算机系统中均以二进制的补码形式来进行运算。
		 * 所以其反码为：1111 1100
		 * 其补码为：1000 0011
		 * 换算为十进制为-3
		 */

		System.out.println(a); // 输出：6
		System.out.println(b); // 输出：0
		System.out.println(c); // 输出：-3
	}
	/**
	 * 位运算符"<<"用于将指定整数的二进制形式全部向左移动指定的位数(包括符号位)，
	 * 移动后，左侧超出范围的部分直接舍弃，左侧空出来的部分全部用0来补充。
	 */
	public static void leftMove(){
		byte a = 25 << 2;
		/*
		 * 25的补码为：0001 1001 
		 * 左移2位为：0110 01**(左侧超出的"00"被舍弃掉)
		 * 右侧空出来的部分全部用0来填充，所以得到的结果为：
		 * 0110 0100
		 * 换算为十进制为100
		 */
		System.out.println(a); // 输出：100
	}
	/**
	 * 按位无符号右移(>>>)

		位运算符">>>"用于将指定整数的二进制形式全部向右移动指定的位数(包括符号位)，移动后，
		右侧超出范围的部分直接舍弃，左侧空出来的部分全部用0来补充。
	 */
	public static void unrightmove(){
		byte a = 27 >>> 3;
		/*
		 * 27的补码：0001 1011
		 * 右移三位：***0 0011(右侧超出的"011"被舍弃掉)
		 * 无符号右移左侧空出来的部分用0来填充，得到：
		 * 0000 0011
		 * 换算成十进制为3
		 */
		byte b = -16 >>> 28;
		/*
		 *在Java中参与位运算的整数实际上为int类型(32位二进制数)，在上面的例子中，为了易于理解，因此以8位二进制形式来表示。
		 *这里我们还原为32位二进制来分析。 
		 *-16的原码：10000000 00000000 00000001 00000000 
		 *-16的反码：11111111 11111111 11111110 11111111
		 *-16的补码：11111111 11111111 11111111 00000000
		 * 右移28位：******** ******** ******** ****1111
		 * 左侧空白用0填充，得到：
		 * 00000000 00000000 00000000 00001111
		 * 换算成十进制为15
		 */

		System.out.println(a);  //输出：3
		System.out.println(b);  //输出：15
	}
	public static void notiy(){
//		注意：在PHP中，没有无符号右移运算符(>>>)。 此外，众所周知，
//		在大多数编程语言中，byte类型为8位二进制，int类型为32位二进制，
//		如果我们将一个int类型的数左移或右移的位数超过了32位会怎么样呢？ 
//		实际上，当位移的位数超过数据类型的位数限制时，这样的运算是没有意义的。
//		为了避免这种情况的出现，当位移的位数(bits)大于等于数据类型最大位数(limit)的限制时，
//		编程语言会用bits除以limit，然后用得到的余数来替代bits(当然，编程语言为了效率，实际上用的是位运算：bits & (limit - 1)，
//				这里用除法求余来说明，以便于读者理解。)。请参考下面的例子。
		// Java的int类型为32位二进制数
		int x = 16 >> 33; // 33 % 32 = 1， 相当于：16 >> 1
		int y = 17 << 34; // 34 % 32 = 2， 相当于：17 << 2
		int z = -9 >>> 56;// 56 % 32 = 24， 相当于：-19 >>> 24

		System.out.println(x); // 输出：8
		System.out.println(y); // 输出：68
		System.out.println(z); // 输出：255
	}
}